# 一、概述
垃圾收集（GC）；为什么我们要了解GC和内存分配呢？

很简单：当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集称为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。

程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭；在这几个区域内就不需要考虑回收的问题。

# 二、垃圾收集算法
## 标记——清除算法
最基础的垃圾收集算法是“标记——清除算法”，算法分标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一进行回收所有被标记的对象。

主要的不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片。
## 复制算法
为了解决效率问题，“复制”收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另外一块上面，然后再把已经使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。代价是将内存缩小是为了原来的一半，未免太高了一点。

（现在的商业虚拟机都采用这种收集算法来回收新生代。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是说每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。）
## 标记——整理算法
“标记——整理”算法，标记过程仍然与“标记——清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
## 分代收集算法
当前商业虚拟机的垃圾收集都采用“分代收集”算法，根据对象存活周期的不同将内存划分几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中就选用复制算法；而老年代中必须使用“标记——清理”或者“标记——整理”算法来进行回收。


# 三、垃圾收集器
HotSpot虚拟机
## Serial收集器 
Serial收集器是一个单线程的收集器，在它进行垃圾收集时，必须暂停其他的工作线程，直到它收集结束。
Serial收集器优于其他收集器的地方是：简单而高效。
## ParNew收集器
ParNew收集器就是Serial收集器的对现场版本，ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器，有一个很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。
（随着可以使用的CPU的数量增加，它对于GC时系统资源的有效利用是有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境下，可以使用-XX：ParallelGCThrads参数来限制垃圾收集的线程数。）
## Parallel Scavenge收集器
Parallel Scavenge收集数是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间））。

停顿时间越短越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。

## Serial Old 收集器
Serial Old是Serial收集器的老年代版本，给Client模式下的虚拟机使用。两大用途：一种用途是在JDK1.5以及之前的版本中与Parallel Scavnege收集器搭配使用；另一种用途是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。
## Parallel Old收集器
Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。
在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。
## CMS收集器
CMS收集器是一种以获取最短回收停顿时间为目标的收集器。Java应用集中在互联网或B/S系统的服务器上，这类应用尤其重视服务的相应速度，希望停顿时间最短，以给用户带来较好的体验。
CMS收集器是基于“标记-清除”算法实现的，整个过程分为4个步骤：初始标记、并发标记、重新标记、并发清除。
（初始标记、重新标记这两个步骤仍然需要“Stop the World"。初始化标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始阶段稍长一些，但远比并发标记的时间短。）

CMS是一款优秀的收集器，的主要优点：并发收集、低停顿；有3个明显的缺点：（1）CMS收集器对CPU资源非常敏感；（2）CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure"失败而导致一次Full GC的产生；（3）CMS是一款基于”标记-清除“算法实现的收集器，意味着收集结束时会有大量空间碎片产生。

### G1收集器
G1是一款面向服务端的垃圾收集器，替换掉JDK1.5发布的CMS收集器；G1具有如下特点：
（1）并行与并发（2）分代收集（3）空间整合（4）可预测的停顿
使用G1收集器时，Java堆的内存布局将整个Java堆划分为多个大小相等的独立区域，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Regin(不需要连续）的集合。
使用Regin划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。





















