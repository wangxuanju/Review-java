# 一、概述
垃圾收集（GC）；为什么我们要了解GC和内存分配呢？

很简单：当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集称为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。

程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭；在这几个区域内就不需要考虑回收的问题。

# 二、垃圾收集算法
## 标记——清除算法
最基础的垃圾收集算法是“标记——清除算法”，算法分标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一进行回收所有被标记的对象。

主要的不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片。
## 复制算法
为了解决效率问题，“复制”收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另外一块上面，然后再把已经使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。代价是将内存缩小是为了原来的一半，未免太高了一点。

（现在的商业虚拟机都采用这种收集算法来回收新生代。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是说每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。）
## 标记——整理算法
“标记——整理”算法，标记过程仍然与“标记——清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
## 分代收集算法
当前商业虚拟机的垃圾收集都采用“分代收集”算法，根据对象存活周期的不同将内存划分几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中就选用复制算法；而老年代中必须使用“标记——清理”或者“标记——整理”算法来进行回收。


# 三、垃圾收集器
HotSpot虚拟机
## Serial收集器 
Serial收集器是一个单线程的收集器，在它进行垃圾收集时，必须暂停其他的工作线程，直到它收集结束。
Serial收集器优于其他收集器的地方是：简单而高效。
## ParNew收集器
ParNew收集器就是Serial收集器的对现场版本，ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器，有一个很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。
（随着可以使用的CPU的数量增加，它对于GC时系统资源的有效利用是有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境下，可以使用-XX：ParallelGCThrads参数来限制垃圾收集的线程数。）
## Parallel Scavenge收集器
Parallel Scavenge收集数是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间））。


