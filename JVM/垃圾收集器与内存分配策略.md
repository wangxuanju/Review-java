一、概述
垃圾收集（GC）；为什么我们要了解GC和内存分配呢？很简单：当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集称为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。
程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭；在这几个区域内就不需要考虑回收的问题。

一、垃圾收集算法
（1）标记——清除算法
最基础的垃圾收集算法是“标记——清除算法”，算法分标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一进行回收所有被标记的对象。
主要的不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片。
（2）复制算法
为了解决效率问题，“复制”收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另外一块上面，然后再把已经使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。代价是将内存缩小是为了原来的一半，未免太高了一点。


二、垃圾收集器
