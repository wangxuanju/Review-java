1 线程
（1）一个标准的线程由线程ID、当前指令指针、寄存器集合和堆栈组成；线程是进程中的一个实体，是被系统独立调度和分派的基本单元，线程自己不拥有系统资源，只拥有一点
在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。
（2）进程在执行过程中，也可以产生多个线程；
（3）在一个进程中，可以有一个或多个线程的存在。
（4）进程和线程最大的区别在于，进程是由操作系统来控制的，而线程是由进程来控制的。
2 java的多线程
2.1 java与多线程
java编写的程序都运行在java虚拟机（JVM）中，在JVM的内部，程序的多任务是通过线程来实现的；
每当使用java命令启动一个java应用程序，就会启动一个JVM进程；在同一个JVM进程中，有且只有一个进程，就是它自己。
2.2 java的线程状态及转换
一个线程在任何时候总是处于5中状态之一：
（1）新建：当创建一个Thread类和它的子类对象后，新产生的线程对象处于新建的状态，并获得除CPU外所需的资源。
（2）就绪：当处于新建状态的线程被启动后，将进入线程队列等待CPU资源。这时，它已经具备了运行的条件，一旦获得CPU资源，就可以脱离创建它的主线程独立运行了；
另外，原来处于阻塞状态的线程结束阻塞状态后，也将进入就绪状态。
（3）运行：当一个就绪状态的线程获得CPU时，就进入了运行状态；每个Thread类及其子类对象都有一个run()方法，一旦线程开始运行，就会自动运行该方法，在run()
方法中定义了线程的所有的操作。
（4）阻塞：一个正在运行的线程因为某种特殊的情况，比如，某种资源无法满足，会让出CPU并暂停自身的运行，进入阻塞状态。只有当引起阻塞的原因消除时，它才能重新
进人就绪状态。
（5）死亡：不具备继续运行能力的线程处于死亡状态。这一般是由两种情况引起的，一种是run()方法已经运行完毕了；另一种是由其他的线程（一般是主线程）强制终止它

需要指出的是：处于就绪状态的线程是在就绪队列中等待CPU资源的，而一般情况下，就绪队列中会有多个线程；为此，系统会个每一个线程分配一个优先级，优先级高的可以
排在较前面的位置，能优先得到CPU资源。对于优先级相同的线程，一般按照先来先服务的原则调度。
2.3 多线程程序的编写
在java中有两种方法可以创建线程：一种是继承Thread类，另一种是Runnable接口（无论哪种方式都要用到java类库中的Thread类以及相应的方法）
2.3.1 Thread类
利用Thread类创建一个线程，必须创建一个从Thread类导出的新的子类；必须覆盖Thread的run()方法来完成线程的业务工作；当启动线程时则必须调用Thread的
start()函数。
2.3.2 Runnable接口
（1）Runnable接口只有一个函数，即run()，此函数必须由实现了此接口的类实现。
（2）当使用runnable接口时，必须从Thread类的一个实例内部运行它。
（3）一个java类只能继承一个父类，但可以实现多个接口；如果有一个类已经继承了一个其他的父类，而又要在此类中实现多线程时，那么继承Thread类来实现多线程的
方法就不能用了，就可以通过实现Runnable接口的方式定义多线程。
注意：在实际的java程序开发中，我们倾向于通过实现Runnable接口的方式实现多线程。

3 多线程程序的编写
3.1 利用Thread的子类来创建线程
要创建一个多线程程序，首先要写一个子类程序继承Thread类，并覆盖其中的run()方法。run()方法中的代码就是这个线程要实现的功能；
然后再创建子类对象，最后调用start()方法来启动线程（如果要对线程进行其他的控制，就需要使用Thread类的其他辅助方法）。
3.2 实现Runnable接口创建线程
另一种实现多线程的程序：实现Runnable接口，Runnable接口中只有一个方法——run()。
实际编程中，实现Runnable的子类中，通常会定义一个Thread类的对象，然后利用Thread的构造方法：
Thread（Runnable target）或Thread(Runnable target,String name)
将本类作为参数传递给Thread对象，这样就可以指定要运行的run()方法；同时，它可以使用Thread类中定义好的其他的辅助方法。
除此之外，为了启动这个线程，还需要定义一个start（）方法，以启动内部的







4 线程的调度与通信




