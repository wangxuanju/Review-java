1 线程
（1）一个标准的线程由线程ID、当前指令指针、寄存器集合和堆栈组成；线程是进程中的一个实体，是被系统独立调度和分派的基本单元，线程自己不拥有系统资源，只拥有一点
在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。
（2）进程在执行过程中，也可以产生多个线程；
（3）在一个进程中，可以有一个或多个线程的存在。
（4）进程和线程最大的区别在于，进程是由操作系统来控制的，而线程是由进程来控制的。
2 java的多线程
##2.1 java与多线程
java编写的程序都运行在java虚拟机（JVM）中，在JVM的内部，程序的多任务是通过线程来实现的；
每当使用java命令启动一个java应用程序，就会启动一个JVM进程；在同一个JVM进程中，有且只有一个进程，就是它自己。
2.2 java的线程状态及转换
一个线程在任何时候总是处于5中状态之一：
（1）新建：当创建一个Thread类和它的子类对象后，新产生的线程对象处于新建的状态，并获得除CPU外所需的资源。
（2）就绪：当处于新建状态的线程被启动后，将进入线程队列等待CPU资源。这时，它已经具备了运行的条件，一旦获得CPU资源，就可以脱离创建它的主线程独立运行了；
另外，原来处于阻塞状态的线程结束阻塞状态后，也将进入就绪状态。
（3）运行：当一个就绪状态的线程获得CPU时，就进入了运行状态；每个Thread类及其子类对象都有一个run()方法，一旦线程开始运行，就会自动运行该方法，在run()
方法中定义了线程的所有的操作。
（4）阻塞：一个正在运行的线程因为某种特殊的情况，比如，某种资源无法满足，会让出CPU并暂停自身的运行，进入阻塞状态。只有当引起阻塞的原因消除时，它才能重新
进人就绪状态。
（5）死亡：不具备继续运行能力的线程处于死亡状态。这一般是由两种情况引起的，一种是run()方法已经运行完毕了；另一种是由其他的线程（一般是主线程）强制终止它

需要指出的是：处于就绪状态的线程是在就绪队列中等待CPU资源的，而一般情况下，就绪队列中会有多个线程；为此，系统会个每一个线程分配一个优先级，优先级高的可以
排在较前面的位置，能优先得到CPU资源。对于优先级相同的线程，一般按照先来先服务的原则调度。
2.3 多线程程序的编写
在java中有两种方法可以创建线程：一种是继承Thread类，另一种是Runnable接口（无论哪种方式都要用到java类库中的Thread类以及相应的方法）
2.3.1 Thread类
利用Thread类创建一个线程，必须创建一个从Thread类导出的新的子类；必须覆盖Thread的run()方法来完成线程的业务工作；当启动线程时则必须调用Thread的
start()函数。
2.3.2 Runnable接口
（1）Runnable接口只有一个函数，即run()，此函数必须由实现了此接口的类实现。
（2）当使用runnable接口时，必须从Thread类的一个实例内部运行它。
（3）一个java类只能继承一个父类，但可以实现多个接口；如果有一个类已经继承了一个其他的父类，而又要在此类中实现多线程时，那么继承Thread类来实现多线程的
方法就不能用了，就可以通过实现Runnable接口的方式定义多线程。
注意：在实际的java程序开发中，我们倾向于通过实现Runnable接口的方式实现多线程。

3 多线程程序的编写
3.1 利用Thread的子类来创建线程
要创建一个多线程程序，首先要写一个子类程序继承Thread类，并覆盖其中的run()方法。run()方法中的代码就是这个线程要实现的功能；
然后再创建子类对象，最后调用start()方法来启动线程（如果要对线程进行其他的控制，就需要使用Thread类的其他辅助方法）。
3.2 实现Runnable接口创建线程
另一种实现多线程的程序：实现Runnable接口，Runnable接口中只有一个方法——run()。
实际编程中，实现Runnable的子类中，通常会定义一个Thread类的对象，然后利用Thread的构造方法：
Thread（Runnable target）或Thread(Runnable target,String name)
将本类作为参数传递给Thread对象，这样就可以指定要运行的run()方法；同时，它可以使用Thread类中定义好的其他的辅助方法。
除此之外，为了启动这个线程，还需要定义一个start（）方法，以启动内部的Thread对象。
（当某类已经是某个类的子类，而同时又要完成多线程任务时，就可以考虑实现Runnable接口）
3.3 使用isAAlive()和join()等待子线程结束
等待线程结束常用的方法时join():
final void join() throws InterruptedException
join()的附加形式允许给等待指定线程结束定义一个最大时间。
3.4 设置线程优先级
JVM程序员自行设置线程优先级，设置线程优先级需要用到setPriority()方法，该方法也是Thread的成员，它的形式是：
final void setPriority(int level)
level制定了对所调用线程的新的优先权的设置；level的值必须处于MIN_PRIRITY~MAX_PRIORITY范围内；通常它们的值分别是0和10，默认是NORM_PRIORITY，该值是5
这些优先级在Thread中都被定义为final型的常量。
用户也可以通过调用Thread的getProperty()方法来获得当前对象的优先级设置，该方法如下：
final int getProperty()

4 线程的调度与通信
关于互斥、同步、死锁和临界的区别：
互斥：当多个线程需要访问同一资源，而这一资源在某一时刻只允许一个线程访问，那么这些线程就是互斥的。
同步：多个线程需要访问同一资源，而且需要互相配合才能正常工作，那么这些线程运行时就是一种同步关系。
临界区：那么实现线程间的互斥和同步，需要将共享资源放入一个区域，该区域一次只允许一个线程进入。
死锁：如有多个线程互相等待其他线程释放资源，且所有的线程都不释放自己所占有的资源。
4.1 线程的互斥
信号量需要用户自己管理，系统只提供了起到PV原语作用的三个方法及1个关键字。
public final void wait():告知被调用的线程放弃管程进入睡眠，知道其他线程进入形同管程并且调用了notify();
public final void notify():恢复相同对象中第一个调用wait()的线程。
public fianl void notifyAll():恢复相同对象中所有调用wait()的线程，具有最高优先级的线程最先运行。
上面的三个方法时object类的成员方法，由于该类是所有类的基类，所有在任何类中，具有最高优先级的线程最先执行。
wait()是将本线程转入阻塞状态，它会暂时释放占用的资源管程，wait(int mill)运行用户指定阻塞的时间。
notify()是唤醒某个在管程队列中排队等候的线程，notifyAll()则是唤醒所有的阻塞线程。
一个关键字：synchronized关键字是用来标志被同步使用的资源。凡是被synchronized修饰的资源，系统都会为它分配一个管程，这样就能保证在某一时间内，只有一个
线程对象在享有这一资源。所以synchronized也被称为对象锁。
上面的三个方法，都只能使用在synchronized控制的代码块中，synchronized的使用形式有两种：
一种是保护整个方法：访问类型 synchronized 返回值 方法名 （[参数表]）{....}
一种是保护某个指定的对象以及随后的代码块： synchronized（对象名）{.....}

要实现线程的互斥，需要以下几个步骤：
（1）设置一个各个线程共享的信号量，值为true或者false
（2）线程需要访问共享资源前，先检测信号量的值。如果不可用，则调用wait()转入等待状态。
（3）如果可用，则改变信号量的状态，不让其他线程进入。
（4）访问完共享资源后，再修改信号量的状态，运行其他线程的进入。
（5）调用notify()或notifyAll()，唤醒其他等待的线程。

4.2 线程的同步
在某些情况下，两个（或者多个）线程需要严格交替的进行。
一种容易想到的方法是设计一个公共类，信号量和共享资源都以静态成员变量的形式存在类中。这么做简单，但不大符合OOP对数据封装的要求。
另一个棘手的问题是：由于两个线程对象分属于不同的线程类，而notify()只能通知本线程类的其它对象；所以需要用“对象名.notify()”的形式，唤醒指定的其它线程
类创建的线程对象。

4.3 暂停、恢复和停止线程 
只要程序员在run()方法中定期检查某些信号量，就可以判定线程是否应该被挂起、恢复或者终止它自己的执行。
