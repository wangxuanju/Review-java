# 一、java集合框架
利用java类库帮助我们在程序设计中实现传统的数据结构。

## 将集合中的接口与实现分离
java集合库将接口与实现分离。

队列通常有两种实现方式：一种是使用循环数组；另一种是使用链表。
```java       //每一个实现都可以通过一个实现了Queue接口的类   
//循环数组
public class CircularArrayQueue<E> implements Queue<E>{
    private int head;
    private int tail;
    
    CircularArrayQueue(int capacity){}
    public void add(E element){}
    public E remove(){}
    public int size(){}
    private E[] elements;
}
//链表
public class LinkedListQueue<E> implements Queue<E>{
    private int head;
    private Link tail;
    
    LinkedListQueue(){}
    public void add(E element){}
    public E remove(){}
    public int size(){}
}
注释：如果需要一个循环数组队列，就可以使用ArrayDeque类；如果需要一个链表队列，就使用LinkedList类，这个类实现了Queue接口。 
```
只有在构建集合对象时，使用具体的类采用意义；可以使用接口类型存放集合的引用。
```java
Queue<Customer> expressLane = new CircularArrayQueue<>(100);
expressLane.add(new Customer("Harry"));
```
利用这种方式，一旦改变了想法，可以轻松的使用另外一个不同的实现；只需要对程序的一个地方做出修改，即调用构造器的地方（如果觉得LinkedListQueue是个更好的选择，对代码进行修改如下：）
```java 
Queue<Customer> expressLane  = new LinkedListQueue<>();
expressLane.add(new Customer("Harry"));
```
循环数组要比链表的实现更加高效，但是循环数组是一个有界集合，即容量有限；如果程序中要收集的对象数量没有上限，就做好使用链表来实现。

备注：在研究API文档时，发现另外一组名字以Abstract开头的类，例如AbstractQueue，这些类是为类库设计者而实现的。

## Collection接口
在java类库中，集合类的基本接口时Collection接口，这个接口有两个基本方法：
```java
public interface Collection<E>{
    boolean add(E element);
    Iterator<E> iterator();
    ...
}
```
add方法用于向集合中添加元素；如果添加元素确实改变了集合就返回true;(如果试图向集合中添加一个对象，而这个对象在集合中已经存在，这个添加请求就没有实效，因为集合不允许有重复的对象。

iterator方法用于返回一个实现了Iterator接口的对象；可以使用这个迭代器对象依次访问集合中的元素。
## 迭代器
Iterator接口包含四个方法：
```java
public interface Iterator<E>{
    E next();
    boolean hasNext();
    void remove();
    default void forEachRemaining(Consumer <? super E> action)    
}
```
通过反复调用next方法，可以逐个访问集合中的每个元素；需要在调用next之前调用hasNext方法；如果迭代器对象还有多个供访问的元素，这个方法就返回true;如果想要查看集合中的所有元素，就请求一个迭代器，并在hasNext返回true时反复的调用next方法。
```java
Collection<String> c = ...;
Iterator<String> iter = c.iterator();
while(iter.hasNext()){
    String element = iter.next();
    do something with elemnt
}
用for each 循环可以更简练的表示同样的循环操作
for(String element : c){
    do something with element 
}
```
for each 循环可以与任何实现了Iterator接口的对象一起工作，这个接口包含了一个抽象方法：
```java
public interface Iterable<E>{
    Iterator<E> iterator();
    ....
}
```
Collection接口扩展了Iterable接口；对于标准类库中的任何集合都可以使用"for each "循环。   

注释：Iterator接口的next和hasNext方法与Enumeration接口的nextElement和hasMoreElement方法的作用一样。

java迭代器查找操作与位置变更是紧密相连的，查找一个元素的唯一方法是调用next，而在执行查找操作的同时，迭代器的位置随之向前移动。


Iterator接口的remove方法将会删除上次调用next方法时返回的元素。然而，如果想要删除指定位置上的元素，仍然需要越过这个元素，例如删除字符串集合中第一个元素的方法：
```java
Iteration<String> it = c.iterator();
it.next();
it.remove();
```
如果调用remove之前没有调用next将是不合法的；如果这样做，将会抛出一个IllegalStateException异常。
如果想删除两个相邻的元素，必须先调用next越过将要删除的元素。
```java
it.remove();
it.next();
it.remove();//OK
```

## 泛型实用方法









# 二、具体的集合








三、映射




四、视图与包装器





五、算法




六、遗留的集合



