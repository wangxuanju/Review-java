# 一、java集合框架
利用java类库帮助我们在程序设计中实现传统的数据结构。

## 将集合中的接口与实现分离
java集合库将接口与实现分离。

队列通常有两种实现方式：一种是使用循环数组；另一种是使用链表。
```java       //每一个实现都可以通过一个实现了Queue接口的类   
//循环数组
public class CircularArrayQueue<E> implements Queue<E>{
    private int head;
    private int tail;
    
    CircularArrayQueue(int capacity){}
    public void add(E element){}
    public E remove(){}
    public int size(){}
    private E[] elements;
}
//链表
public class LinkedListQueue<E> implements Queue<E>{
    private int head;
    private Link tail;
    
    LinkedListQueue(){}
    public void add(E element){}
    public E remove(){}
    public int size(){}
}
注释：如果需要一个循环数组队列，就可以使用ArrayDeque类；如果需要一个链表队列，就使用LinkedList类，这个类实现了Queue接口。 
```
只有在构建集合对象时，使用具体的类采用意义；可以使用接口类型存放集合的引用。
```java
Queue<Customer> expressLane = new CircularArrayQueue<>(100);
expressLane.add(new Customer("Harry"));
```
利用这种方式，一旦改变了想法，可以轻松的使用另外一个不同的实现；只需要对程序的一个地方做出修改，即调用构造器的地方（如果觉得LinkedListQueue是个更好的选择，对代码进行修改如下：）
```java 
Queue<Customer> expressLane  = new LinkedListQueue<>();
expressLane.add(new Customer("Harry"));
```
循环数组要比链表的实现更加高效，但是循环数组是一个有界集合，即容量有限；如果程序中要收集的对象数量没有上限，就做好使用链表来实现。

备注：在研究API文档时，发现另外一组名字以Abstract开头的类，例如AbstractQueue，这些类是为类库设计者而实现的。

## Collection接口
在java类库中，集合类的基本接口时Collection接口，这个接口有两个基本方法：
```java
public interface Collection<E>{
    boolean add(E element);
    Iterator<E> iterator();
    ...
}
```
add方法用于向集合中添加元素；如果添加元素确实改变了集合就返回true;(如果试图向集合中添加一个对象，而这个对象在集合中已经存在，这个添加请求就没有实效，因为集合不允许有重复的对象。

iterator方法用于返回一个实现了Iterator接口的对象；可以使用这个迭代器对象依次访问集合中的元素。
## 迭代器
Iterator接口包含四个方法：
```java
public interface Iterator<E>{
    E next();
    boolean hasNext();
    void remove();
    default void forEachRemaining(Consumer <? super E> action)    
}
```
通过反复调用next方法，可以逐个访问集合中的每个元素；需要在调用next之前调用hasNext方法；如果迭代器对象还有多个供访问的元素，这个方法就返回true;如果想要查看集合中的所有元素，就请求一个迭代器，并在hasNext返回true时反复的调用next方法。
```java
Collection<String> c = ...;
Iterator<String> iter = c.iterator();
while(iter.hasNext()){
    String element = iter.next();
    do something with elemnt
}
用for each 循环可以更简练的表示同样的循环操作
for(String element : c){
    do something with element 
}
```
for each 循环可以与任何实现了Iterator接口的对象一起工作，这个接口包含了一个抽象方法：
```java
public interface Iterable<E>{
    Iterator<E> iterator();
    ....
}
```
Collection接口扩展了Iterable接口；对于标准类库中的任何集合都可以使用"for each "循环。   

注释：Iterator接口的next和hasNext方法与Enumeration接口的nextElement和hasMoreElement方法的作用一样。

java迭代器查找操作与位置变更是紧密相连的，查找一个元素的唯一方法是调用next，而在执行查找操作的同时，迭代器的位置随之向前移动。


Iterator接口的remove方法将会删除上次调用next方法时返回的元素。然而，如果想要删除指定位置上的元素，仍然需要越过这个元素，例如删除字符串集合中第一个元素的方法：
```java
Iteration<String> it = c.iterator();
it.next();
it.remove();
```
如果调用remove之前没有调用next将是不合法的；如果这样做，将会抛出一个IllegalStateException异常。
如果想删除两个相邻的元素，必须先调用next越过将要删除的元素。
```java
it.remove();
it.next();
it.remove();//OK
```

## 泛型实用方法
由于Collection与Iterator都是泛型接口，可以编写操作任何集合类型的实用方法。
```java  //contains方法时检测任意集合是否包含指定元素的泛型方法
public static <E> boolean contains(Collection<E> c,Object obj){
    for(E elemnt:c)
        if(element.equals(obj))
            return true;
    return false;
}
```

事实上，Collection接口声明了许多有用的方法，所有的实现类都必须提供这些方法；
```java
int size()
boolean isEmpty()
boolean contains(Object obj)
boolean containsAll(Collection<?> c)
boolean equals(Object other)
boolean addAll(Collection<?extends E>from)
boolean remove(Object obj)
boolean removeAll(Collection<?> c)
void clear()
boolean retainAll(Collection<?> c)
Object[] toArray()
<T> T[] toArray(T[] arrayToFill)
```

为了能够让实现者更容易的实现Collection接口，java类库提供了一个类AbstractCollection,它将size和iterator抽象化了，但是在此提供了例行方法：
```java
public abstract class AbstractCollection<E> implements Collection<E> {
    ...
    public abstract Iterator<E> iterator();
    
    public boolean contains(Object obj){
        for(E element:this)
            if(element.equals(obj))
                return = true;
        return false;
    }
    ...
}
```
此时一个具体的集合类可以扩展AbstractCollection类，现在要由具体类提供iterator方法，而contains方法已由AbstractCollection超类提供的。
另外一个有用的方法：
```java
default boolean removeIf(Predicate<? super E> filter)
```




# 二、具体的集合








三、映射




四、视图与包装器





五、算法




六、遗留的集合



