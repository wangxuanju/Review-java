<!-- GFM-TOC -->
* [一、面向对象](#一面向对象)
* [二、类和对象](#二类和对象)
    * [类的基本结构](#类的基本结构)
    * [创建类体](#创建类体)
    * [对象的创建](#创建类体)
* [三、成员变量的定义与使用](#三成员变量的定义与使用)
    * [成员变量的定义](#成员变量的定义)
    * [成员变量的访问权限](#成员变量的访问权限)
    * [实例成员变量和静态成员变量](#实例成员变量和静态成员变量)
* [四、方法的定义和实现](#四方法的定义和实现)
    * [方法的声明](#方法的声明)
    * [return语句](#return语句)
    * [局部变量和成员变量的区别](#局部变量和成员变量的区别)
    * [局部变量与成员变量同名问题](#局部变量与成员变量同名问题)
* [五、方法的调用](#五方法的调用)
* [六、构造方法](#六构造方法)
    * [构造方法的一般形式](#构造方法的一般形式)
    * [无参的构造方法](#无参的构造方法)
    * [带参数的构造方法](#带参数的构造方法)
    * [this关键字和构造方法的调用](#this关键字和构造方法的调用)
* [七、静态方法](#七静态方法)
    * [静态方法的定义](#静态方法的定义)
    * [静态方法和实例方法的区别](#静态方法和实例方法的区别)
    * [静态代码块](#静态代码块)
* [八、main()方法和命令行参数](#八main()方法和命令行参数)

<!-- GFM-TOC -->

# 一、面向对象
类：类是具有共同属性、共同操作的对象的集合；单个对象则是所属类的一个成员，或称为实例；
面向对象的基本特征：抽象、封装、继承、多态；

# 二、类与对象
## 类的基本结构
[类修饰符] class 类名 [extends 父类名] [implements 接口名列表]
修饰符 final——最终类，它不能拥有子类；
abstract——抽象类，类中的方某些方法没有实现，必须由其子类来实现；
public——公共类，public表明本类可以被所属包以外的类访问；
## 创建类体
```java
class className{
    成员变量
    成员方法
    构造方法
}
```
变量和方法都是类的成员；对类的成员来说，可分为实例成员和类（静态）成员两种；
## 对象的创建
要使用类需要通过类的实例——对象来实现
类名 对象名 = new 构造方法名 （[参数列表]）;
包含三个步骤：声明、实例化和初始化；
类名 对象名；//声明对象
new 构造方法（[参数列表]）//实例化对象
初始化对象——java规定，如果成员变量没有被显示的赋值，系统将自动为它们赋初值；
（所有简单变量除boolean类型外均赋初值为0，boolean类型赋初值为false,其它类型的对象均赋值为null）
## 对象的使用
对象变量的使用——对象名.成员变量名 eg pt.x=6;
对象方法的调用——对象名.成员方法名（[参数列表]）eg pt.move(5,5);

# 三、成员变量的定义与使用
## 成员变量的定义
成员变量的定义——成员变量是定义在类里面，并和方法处于同一层次
[变量修饰符] 类型说明符 变量名
在一个类中成员变量应该是唯一的；
成员变量的类型可以是java中任意数据类型，包括基本类型、数组、类和接口；

（1）实例成员，在外部需要通过对象才能操作；

（2）静态成员，无需通过对象就能操作；
```java
private double width,heigth;//定义两个私有的成员变量
public static int count;       //定义一个公共的静态类变量
public static final int COLORE=1；//定义一个公共的整型静态常量
```
## 成员变量的访问权限
（1）公共变量——被public修饰的成员变量；允许在该变量所属的类中所有的方法访问，也允许其他类在外部访问；
（允许类在外部直接访问，破坏了封装原则，造成数据安全性下降；除非特别有需要，否则不要使用这种方案）

（2）私有变量——只允许在本类的内部访问，任何外部类都不能访问它；
为了让外部用户能够访问某些私有变量，通常类的设计者会提供一些方法给外部调用，这些方法被称为访问接口；所有的私有变量都只能通过程序员设计的接口来访问，
任何外部使用者都无法直接访问它；

（3）保护变量——被protected修饰的变量；除了允许在本类的内部访问之外，还允许它的子类以及同一个包中的其它类访问；
备注：子类如果和父类不在同一个包中，将无法通过‘对象名.变量名’的方式来访问protected类型的成员变量；

（4）默认的访问变量——frendly变量；只允许在同一个包中的其它类访问，即便是子类不在同一包中也不能访问；

## 实例成员变量和静态成员变量
（1）实例成员变量

在类的内部，实例成员方法也可以直接访问实例成员变量；
在类的外部使用实例成员变量，需要先创建一个对象，然后通过‘对象名.变量名’来访问；

（2）静态成员变量——成员变量前加上static标识符就可以定义一个静态成员变量；
静态成员变量的特点：
它被类的所有对象共享，因此又被称为类变量；
保存在类的公共存储单元；可以在类的对象被创建之前就能使用；
可以通过‘对象名.变量名’的方式访问，也可以通过‘类名.变量名’的方式访问，二者完全等价；

eg 静态变量stat是一个公共变量，无论哪个对象改变了它的值，对其他的所有该类的对象都有效；

# 四、方法的定义和实现
## 方法的声明
[方法修饰符] [方法返回值类型] 方法名 （[形式参数表]）

（1）方法的返回值类型也和成员变量的数据类型一样，可以是基本类型：int/char和double等，也可以是类类型。

（2）形式参数列表是方法可以接收的参数，它由外部调用者提供具体的值。

##  return语句

return [表达式];

java规定：任何一个返回值不为void的方法，都必须至少有一个return语句。return后面的表达式类型必须与返回类型相容。相容是指：类型完全相同或者表达式的类
型可以通过扩展类型转换为与返回类型相同的类型；
如果是void类型的方法，则可以不需要return语句；如果有return语句，则return语句后面的表达式应为空。
（在方法中如果有return语句，则只要执行到return语句，立即返回调用者；无论该return语句后面还有多少语句，都不会被执行。一个方法中可以由多条return语句
，但一次调用时，只能执行某一条return语句，其余的无效）
 ## 局部变量和成员变量的区别
 
 [变量修饰符] 变量类型 变量名
 
 （1）可以在一行中定义多个局部变量，以逗号隔开
 
 （2）定义变量时可以同时赋值
 
 （3）变量修饰符可以是final，表示这是常量
 
 注：局部变量没有访问权限修饰符；局部变量不能用static修饰，没有‘静态局部变量’；系统不会自动为局部变量赋初值（成员变量则会赋初值）；不同的方法中可以有
 同名的局部变量；在方法的外部无法访问局部变量，因为局部变量的作用域仅限于定义它的方法；局部变量的作用域仅限于定义它的方法。
 ## 局部变量与成员变量同名问题
 在方法中同名的局部变量会屏蔽掉成员变量；在方法中为了访问被屏蔽的成员变量，需要使用一个前缀this，它表示的是'本对象'; 
 
# 五、方法的调用
（1）调用者和被调用方法位于同一类中

[this.]方法名（[实际参数列表]）多数情况下，关键字this可以省略

(2)调用者位于被调用者方法所在类的外部

对象名.方法名（[实际参数列表]） 或者 类名.方法名（[实际参数列表]） 

实际参数列表是对应方法的形式参数列表

重点部分：方法调用的参数
定义一个方法时，根据需要列出一个参数表，这些参数被称为形式参数；在调用方法时，需要调用者提供与之相匹配的参数表，被称为实际参数；

# 六、构造方法
##  构造方法的一般形式
```java
构造方法名（[参数列表]）{
    [this([参数列表]);]|[super([参数列表]);
    语句序列
}this是调用其它的构造方法，super是调用父类的构造方法；它们都必须放在其他语句的前面。
```
（1）构造方法的名字必须与类的名字完全相同；

（2）只能有访问权限修饰符，不能有其它任何修饰符，也不能有返回值；不能用static和final修饰，一般也不能用private修饰。

（3）尽管没有返回值，也不能用void修饰；

（4）构造方法的参数可以为空，也可以有参数；

（5）同一个类可以有多个构造方法，但要求参数列表不同；

（6）当用户定义的类为提供任何构造方法时，系统会自动为其提供一个无参数的构造方法。

##  无参的构造方法
java规定：如果程序员一个构造方法都不定义，那么系统会自动的为其加上一个不带参数的构造方法；如果程序员至少定义了一个构造方法，那么系统不会再提供不带参数的构造方法。
## 带参数的构造方法
强烈建议：程序员定义带参数的构造方法时，同时定义一个不带参数的构造方法，即便这个方法什么事情也不做。
java允许定义带参数的构造方法，而且这种带参数的构造方法还可以定义多个，这种现象称为构造方法的重载。
## this关键字和构造方法的调用
this([参数列表])
（1）用this调用构造方法时，该语句只能用在构造方法中；

（2）this语句必须是构造方法中的第一条语句；

（3）和new不同，this虽然可以调用构造方法，但它只是执行构造方法中的语句，并不会创建对象，

# 七、静态方法
## 静态方法的定义
```java
[访问权限修饰符]static [返回值类型]方法名（[参数列表]）{
    语句序列
}
```
## 静态方法和实例方法的区别
（1）在外部调用静态方法时，可以使用'类名.方法名'的方式，也可以使用'对象名.方法名'的方式；而实例方法只有‘对象名.方法名’；也就是说调用静态方法时，无需
创建对象。

（2）静态方法在访问本类的成员时，只允许访问静态成员(即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法王无此限制。
重点知识点：静态方法只能访问静态变量和静态方法；之所以不允许静态方法访问实例成员变量，是因为实例成员变量是属于某个对象的，而静态方法在执行时，并不一定存在对象。同样，因为实例方法可以访问实例成员变量，如果允许静态方法调用实例方法，将间接的允许它使用实例成员变量，所以它不能调用实例方法。基于同样的道理，静态方法中也不能使用关键字this。

注：静态变量被该类所有的对象公有（相当于全局变量），不需要实例化就已经存在；
实例方法必须在类实例化之后通过对象来调用，而静态方法可以在类实例化之前就使用；
## 静态代码块
在类中可以将某一块代码声明为静态的，这样的程序块叫静态初始化段
```java
static {
    语句序列
}
```
（1）静态代码块只能定义在类里面，它独立于任何方法，不能定义在方法里面；

（2）静态代码块里面的变量都是局部变量，只能在本块中使用；

（3）静态代码块会在类被加载时自动执行，无论加载者是JVM还是其他的类；

（4）一个类中允许定义多个静态代码块，执行的顺序根据定义的顺序进行；

（5）静态代码块只能访问类的静态成员，而不允许访问实例成员；

注：静态代码块甚至在mian()方法之前被执行；在mian()方法中可以完成的任务在静态代码块中都可以完成。

# 八、main()方法和命令行参数

main()是静态方法，因此在运行main()方法时，只能使用该类中的静态成员，如果要使用实例成员，需要先创建该类的实例对象，然后用对象来访问实例成员。

main()方法只能被系统调用，因此它的参数也只能由系统传递给它；系统所传递的参数则来自于用户的输入。
