1 继承
[类修饰符] class 子类名 extends 父类名{
    类体
}
（1）子类会自定的继承父类中的所有定义的非private的成员变量和普通方法，唯有构造方法例外。
注：java出于安全性和可靠性的考虑，仅支持单重继承，而通过使用接口机制来实现多重继承；

2 继承中的属性隐藏与方法覆盖
当子类的成员变量和父类的成员变量同名时，称为父类的成员变量（属性）被隐藏；如果是成员方法同名，称为父类的成员方法（行为）被覆盖。
2.1 属性的隐藏
（1）子类变量可以修改继承下来的父类变量中的任何属性，使用子类对象时，以修改之后的属性为准；
（2）java规定，子类用于隐藏的变量可以和父类的访问权限不同，如果访问权限被改变，则以子类的权限为准。
（3）java允许子类的变量与父类的变量的类型完全不同，以修改后的数据类型为准。
（4）java允许父类的变量被子类的常量隐藏，也允许父类的常量被子类的变量隐藏。
2.2 方法的覆盖
子类中如果觉得继承下来的方法不能满足自己的要求，可以将其重写一遍，这被称为‘覆盖’；覆盖必须满足两个条件：
一、方法名称必须相同；二、方法的参数必须完全相同，包括参数的个数、类型和顺序。
如果只满足第一条，而不满足第一条，那么就不是覆盖，而是重载。
（1）子类方法的访问权限可以与父类的不相同，但只允许权限更宽松，而不是更严格。
（2）覆盖与被覆盖的方法的返回值数据类型必须完全相同。
（3）如方法前面有final修饰，则表示该方法是一个最终方法，它的子类不能覆盖该方法；反之，一个非最终方法，可以在子类中指定final修饰符，将其变成最终方法。
（4）java规定，静态方法不允许被实例方法覆盖；同样实例方法也不允许用静态方法覆盖；也就是说，不允许出现父类方法和子类方法覆盖时static修饰符发生变化

3 构造方法的继承与调用
从形式上看，构造方法没有返回值，没有static和final等修饰符，而且一般不会用private修饰。
3.1 构造方法的定义
java中任何变量在被使用前都必须先设置初值，java提供了为类的成员变量赋初值的专门方法即构造方法；
（1）构造方法的名字必须与定义的类名完全相同，没有返回值，甚至连void都没有。
（2）构造方法的调用在创建一个对象时使用new操作进行的；构造方法的作用时初始化对象。
（3）每个类可以有0个或多个构造方法。
（4）不能被static/final/synchronized/abstract/native修饰。
3.2 构造方法的继承
（1）父类中不带参数的构造方法能够被子类自动继承，这种继承与普通方法的继承本质上并不相同，它其实是一种自动调用；
（2）java规定，带参数的构造方法，不会由子类继承，也不会自动调用；
3.3 构造方法的覆盖
（1）构造方法在覆盖时，只可能是访问权限不同；而且它遵循普通方法的限制，只允许访问权限更宽松。java还规定，子类中无论当哪个构造方法在执行时，都会先执行
父类中无参数的构造方法。
（2）子类的构造方法在执行时，会先调用父类中无参数的构造方法；因此在设计一个类时，最好为父类提供一个无参数的构造方法。
3.4 super关键字的使用
子类的变量和方法都可以和父类中的同名；在这种情况下，父类中的同名成员就被屏蔽起来——注意仅仅只是屏蔽，而不是清除；如果想在子类中访问父类的成员，就需要
用到关键字super。
super的一般用法：super.变量名 或 super.方法名（[参数列表]） 
super的另外一个作用是显式的调用父类的构造方法： super（[参数列表]）
（1）关键字super引用被隐藏的变量和访问被覆盖的父类方法；
（2）子类的构造方法会自动调用父类不带参数的构造方法，不会调用带参数的构造方法；如果子类确实有必要调用父类带参数的构造方法，就必须使用super关键字实现
super（[参数列表]）;
使用super的规则：一、只能用在构造方法中；二、只能是第一条执行语句；三、一个构造方法只能有一条super语句
注：一旦显式的用super来调用父类的构造方法，系统就不会再自动的调用父类中无参数的构造方法。
子类继承父类的总结：
（1）如果子类没有定义构造方法，则调用父类的无参数的构造方法。
（2）如果子类定义了构造方法，无论是无参数还是带参数，在创建子类的对象的时候，首先执行父类无参数的构造方法，然后执行自己的构造方法；
（3）如果子类调用父类带参数的构造方法，可以通过super（参数）调用所需要的父类的构造方法，且该语句作为子类构造方法的第一条语句；
（4）如果某个构造方法调用类中的其它的构造方法，则可以用this（参数），且该语句放在构造方法的第一条语句的位置。

4 多态技术
java中多态性表现在两个方面：
方法的重载：在同一个类中，相同的方法名对应不同的方法实现，但是方法的参数不同；
成员覆盖：在不同类（父类和子类）中，允许有相同的变量名，但是参数类型不同；也允许有相同的方法名，但是对应的方法实现不同；
4.1 重载与覆盖
在一个类中，多个方法拥有相同的名字，名字相同的同时必须有不同的参数，这就是重载；
在父类与子类之间，有相同的属性名但类型不同或方法名相同但实现不同，就是子类对父类的成员或方法的覆盖。
4.1.1普通方法的重载
当方法同名时，至少需要之一不同，一、参数个数不同；二、对应位置上的参数类型不同；
注：不允许参数完全相同而只是返回值不同的情况出现。
除了普通实例方法的重载，静态方法之间也可以重载，它们的规则和实例方法的重载一样；甚至静态方法和实例方法之间也可以相互重载，同样要求参数之间有区别。
4.1.2构造方法的重载
相对于普通的成员方法，由于构造方法不能是static和final类型，而且也没有返回值，所以它的重载比普通成员方法更简单一些，但规则完全相同。
注意：如果程序员为类定义了一个构造方法，那么系统不会再自动为其添加一个无参数的构造方法；所以程序员如果要为类定义构造方法，为避免使用者的错误，请务必
定义一个不带参数的构造方法（即程序员无论何种情况，一定要为类定义一个不带参数的构造方法）
4.1.3重载的解析
扩展转换有两条路径：
byte short int long float double 
char int long float double
这两条路径中，位于左边的类型都可以扩展为右边的类型。
4.1.4重载与覆盖的区别
（1）重载与覆盖的方法名称都相同，但重载要求参数列表不同，而覆盖则要求参数列表完全相同。
（2）重载对于方法前面的修饰符没有限制，而覆盖则对这些修饰符的使用有限制。
（3）同一类中的方法能够互相重载，但不能相互覆盖；子类对父类的方法既可以重载又可以覆盖。
（4）重载是一个类中多态性的一种表现，覆盖是父类与子类之间多态性的一种表现。
4.2 重难点——运行时多态


5 结口与多重继承
5.1接口的定义
[访问权限修饰符] interface 接口名 [extends 父接口1，父接口2，...]{
    [public][static][final]数据类型 变量名=初始值；//定义成员变量
    ....
    [public][abstract] 返回类型 方法名 （[参数列表]）//定义成员方法
}
（1）interface表明这是一个接口，访问权限修饰符和类使用的一样，默认访问权是包访问权，一般用public来修饰它；和类的区别是，接口都是abstract的，所以
无需用abstract来修饰；
（2）接口中的成员变量都是常量；接口中的成员变量的属性都是静态的、最终的，也就是静态常量；接口中不允许使用private和protected关键字，意味着所有的属性
都是public类型的。
（3）接口中的成员方法都是抽象方法；所有的方法都是具有public访问权限的抽象实例方法。
（4）接口中的方法都是抽象的，而构造方法不可能是抽象方法，因此接口中没有构造方法。
5.2 接口的继承
接口的继承规则和类的继承是相同的。
5.3 接口的实现
实现接口的一般形式：
[类修饰符] class 类名 [extends父类名] [implements 接口名1 [,接口名2，...]]{
    //实现接口中的抽象方法
    public [返回值类型] 方法名 （[参数表]）{
        //方法体
    }
}
注：实现接口中的方法时，它的访问权限一定要是public类型；它的参数、返回值也要和接口中的形式完全一致；
（1）接口最终要用类来实现；类在实现接口时，不再使用关键字extends，而是使用implements；
（2）若干没有继承关系的类可以实现同一个接口，一个类可以实现多个接口，这些接口被称为父接口或超接口；
（3）由于接口中只有抽象方法，所以一个非抽象的类必须实现父接口中所有的方法；若父接口继承了其它的接口，则这些接口的抽象方法也要由该类来实现；若是该类
同时是某些类的子类，而其父类实现了这些接口中的一部分方法，则该类只要能继承这些方法，也就视为对这些抽象方法的实现；
（4）虽然接口不能直接用来创建对象，但是接口中定义的成员变量是可以直接使用的，因为静态成员不需要创建对象就可以通过‘接口名.变量名’的方式来使用；
6 抽象类与最终类
6.1 抽象方法的声明
java中提供了抽象类，它只能作为父类，不能实例化。
抽象方法是一种只有方法而没有方法体定义的特殊方法；它的声明部分和一般方法没有太大的区别，只是需要在前面加上一个关键字abstract，形式如下：
abstract 访问权限 返回类型 方法名([参数列表]);
声明抽象方法有几个限制：
（1）构造方法不能声明为abstract;
（2）静态方法不能声明为abstract;
（3）private方法不能声明为abstract;
（4）final方法不能声明为abstract;
（5）抽象方法只能出现在抽象类或接口中；
6.2 抽象类的定义
定义一个抽象类，只需要在类的头部加上关键字abstract;
abstract class className{
    类体
}
在抽象类中，可以有0个或多个抽象方法，也可以有普通的实例方法和静态方法，还可以有其它的成员变量和构造方法；如果类中没有任何形式的抽象方法，那么可以由
程序员自主决定是否将类声明为abstract类型；
符合下面条件之一，则类必定为抽象类，必须加上abstract修饰：
（1）类中明确声明有abstract方法；
（2）类是从抽象类继承下来的，而且没有实现父类中全部的抽象方法；
（3）类实现了一个接口，但没有将其中所有的抽象方法实现；
6.3 抽象方法与回调函数
在抽象类中，既可以有抽象方法，也可以有普通方法，而且普通方法还可以调用抽象方法；
抽象方法不能是静态方法，因为静态方法无需对象就能执行；
6.4 最终类与最终方法
6.4.1最终类
最终类定义的一般形式：
[访问权限] final class 类名{
    类体
}
（1）如果一个类不希望被其它类所继承，则可以声明为final类，这样就可以防止其它类以它作为父类；最终类通常是有某个固定作用的类，如system/string类等。
（2）最终类显然不可能是抽象类；由于最终类不能有子类，那么它所拥有的所有方法都不可能被覆盖，因此它其中所有的方法都是最终方法。
6.4.2最终方法
如果一个类允许被其它类所继承，只是其中的某些方法不允许被子类覆盖，那么可以将这些方法声明为最终方法，这需要在声明前面加上关键字final；
[访问权限] final 返回类型 方法名 （[参数列表]）
使用最终方法时，注意两点：
一、最终方法可以出现在任何类中，但不能和abstract修饰符同时使用；
二、最终方法不能被覆盖，但可以被重载；

7 内部类

8 包



