1 继承
[类修饰符] class 子类名 extends 父类名{
    类体
}
（1）子类会自定的继承父类中的所有定义的非private的成员变量和普通方法，唯有构造方法例外。
注：java出于安全性和可靠性的考虑，仅支持单重继承，而通过使用接口机制来实现多重继承；

2 继承中的属性隐藏与方法覆盖
当子类的成员变量和父类的成员变量同名时，称为父类的成员变量（属性）被隐藏；如果是成员方法同名，称为父类的成员方法（行为）被覆盖。
2.1 属性的隐藏
（1）子类变量可以修改继承下来的父类变量中的任何属性，使用子类对象时，以修改之后的属性为准；
（2）java规定，子类用于隐藏的变量可以和父类的访问权限不同，如果访问权限被改变，则以子类的权限为准。
（3）java允许子类的变量与父类的变量的类型完全不同，以修改后的数据类型为准。
（4）java允许父类的变量被子类的常量隐藏，也允许父类的常量被子类的变量隐藏。
2.2 方法的覆盖
子类中如果觉得继承下来的方法不能满足自己的要求，可以将其重写一遍，这被称为‘覆盖’；覆盖必须满足两个条件：
一、方法名称必须相同；二、方法的参数必须完全相同，包括参数的个数、类型和顺序。
如果只满足第一条，而不满足第一条，那么就不是覆盖，而是重载。
（1）子类方法的访问权限可以与父类的不相同，但只允许权限更宽松，而不是更严格。
（2）覆盖与被覆盖的方法的返回值数据类型必须完全相同。
（3）如方法前面有final修饰，则表示该方法是一个最终方法，它的子类不能覆盖该方法；反之，一个非最终方法，可以在子类中指定final修饰符，将其变成最终方法。
（4）java规定，静态方法不允许被实例方法覆盖；同样实例方法也不允许用静态方法覆盖；也就是说，不允许出现父类方法和子类方法覆盖时static修饰符发生变化

3 构造方法的继承与调用
从形式上看，构造方法没有返回值，没有static和final等修饰符，而且一般不会用private修饰。
3.1 构造方法的定义
java中任何变量在被使用前都必须先设置初值，java提供了为类的成员变量赋初值的专门方法即构造方法；
（1）构造方法的名字必须与定义的类名完全相同，没有返回值，甚至连void都没有。
（2）构造方法的调用在创建一个对象时使用new操作进行的；构造方法的作用时初始化对象。
（3）每个类可以有0个或多个构造方法。
（4）不能被static/final/synchronized/abstract/native修饰。
3.2 构造方法的继承
（1）父类中不带参数的构造方法能够被子类自动继承，这种继承与普通方法的继承本质上并不相同，它其实是一种自动调用；
（2）java规定，带参数的构造方法，不会由子类继承，也不会自动调用；
3.3 构造方法的覆盖
（1）构造方法在覆盖时，只可能是访问权限不同；而且它遵循普通方法的限制，只允许访问权限更宽松。java还规定，子类中无论当哪个构造方法在执行时，都会先执行
父类中无参数的构造方法。
（2）子类的构造方法在执行时，会先调用父类中无参数的构造方法；因此在设计一个类时，最好为父类提供一个无参数的构造方法。
3.4 super关键字的使用
子类的变量和方法都可以和父类中的同名；在这种情况下，父类中的同名成员就被屏蔽起来——注意仅仅只是屏蔽，而不是清除；如果想在子类中访问父类的成员，就需要
用到关键字super。
super的一般用法：super.变量名 或 super.方法名（[参数列表]） 
super的另外一个作用是显式的调用父类的构造方法： super（[参数列表]）
（1）关键字super引用被隐藏的变量和访问被覆盖的父类方法；
（2）子类的构造方法会自动调用父类不带参数的构造方法，不会调用带参数的构造方法；如果子类确实有必要调用父类带参数的构造方法，就必须使用super关键字实现
super（[参数列表]）;
使用super的规则：一、只能用在构造方法中；二、只能是第一条执行语句；三、一个构造方法只能有一条super语句
注：一旦显式的用super来调用父类的构造方法，系统就不会再自动的调用父类中无参数的构造方法。
子类继承父类的总结：
（1）如果子类没有定义构造方法，则调用父类的无参数的构造方法。
（2）如果子类定义了构造方法，无论是无参数还是带参数，在创建子类的对象的时候，首先执行父类无参数的构造方法，然后执行自己的构造方法；
（3）如果子类调用父类带参数的构造方法，可以通过super（参数）调用所需要的父类的构造方法，且该语句作为子类构造方法的第一条语句；
（4）如果某个构造方法调用类中的其它的构造方法，则可以用this（参数），且该语句放在构造方法的第一条语句的位置。

4 多态技术

5 结口与多重继承

6 抽象类与最终类

7 内部类

8 包



