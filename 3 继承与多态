1 继承
[类修饰符] class 子类名 extends 父类名{
    类体
}
（1）子类会自定的继承父类中的所有定义的非private的成员变量和普通方法，唯有构造方法例外。
注：java出于安全性和可靠性的考虑，仅支持单重继承，而通过使用接口机制来实现多重继承；

2 继承中的属性隐藏与方法覆盖
当子类的成员变量和父类的成员变量同名时，称为父类的成员变量（属性）被隐藏；如果是成员方法同名，称为父类的成员方法（行为）被覆盖。
2.1 属性的隐藏
（1）子类变量可以修改继承下来的父类变量中的任何属性，使用子类对象时，以修改之后的属性为准；
（2）java规定，子类用于隐藏的变量可以和父类的访问权限不同，如果访问权限被改变，则以子类的权限为准。
（3）java允许子类的变量与父类的变量的类型完全不同，以修改后的数据类型为准。
（4）java允许父类的变量被子类的常量隐藏，也允许父类的常量被子类的变量隐藏。
2.2 方法的覆盖
子类中如果觉得继承下来的方法不能满足自己的要求，可以将其重写一遍，这被称为‘覆盖’；覆盖必须满足两个条件：
一、方法名称必须相同；二、方法的参数必须完全相同，包括参数的个数、类型和顺序。
如果只满足第一条，而不满足第一条，那么就不是覆盖，而是重载。
（1）子类方法的访问权限可以与父类的不相同，但只允许权限更宽松，而不是更严格。
（2）覆盖与被覆盖的方法的返回值数据类型必须完全相同。
（3）如方法前面有final修饰，则表示该方法是一个最终方法，它的子类不能覆盖该方法；反之，一个非最终方法，可以在子类中指定final修饰符，将其变成最终方法。
（4）java规定，静态方法不允许被实例方法覆盖；同样实例方法也不允许用静态方法覆盖；也就是说，不允许出现父类方法和子类方法覆盖时static修饰符发生变化

3 构造方法的继承与调用
从形式上看，构造方法没有返回值，没有static和final等修饰符，而且一般不会用private修饰。
3.1 构造方法的定义
java中任何变量在被使用前都必须先设置初值，java提供了为类的成员变量赋初值的专门方法即构造方法；
（1）构造方法的名字必须与定义的类名完全相同，没有返回值，甚至连void都没有。
（2）构造方法的调用在创建一个对象时使用new操作进行的；构造方法的作用时初始化对象。
（3）每个类可以有0个或多个构造方法。
（4）不能被static/final/synchronized/abstract/native修饰。
3.2 构造方法的继承
（1）父类中不带参数的构造方法能够被子类自动继承，这种继承与普通方法的继承本质上并不相同，它其实是一种自动调用；
（2）java规定，带参数的构造方法，不会由子类继承，也不会自动调用；
3.3 构造方法的覆盖
（1）构造方法在覆盖时，只可能是访问权限不同；而且它遵循普通方法的限制，只允许访问权限更宽松。java还规定，子类中无论当哪个构造方法在执行时，都会先执行
父类中无参数的构造方法。
（2）子类的构造方法在执行时，会先调用父类中无参数的构造方法；因此在设计一个类时，最好为父类提供一个无参数的构造方法。
3.4 super关键字的使用
子类的变量和方法都可以和父类中的同名；在这种情况下，父类中的同名成员就被屏蔽起来——注意仅仅只是屏蔽，而不是清除；如果想在子类中访问父类的成员，就需要
用到关键字super。
super的一般用法：super.变量名 或 super.方法名（[参数列表]） 
super的另外一个作用是显式的调用父类的构造方法： super（[参数列表]）
（1）关键字super引用被隐藏的变量和访问被覆盖的父类方法；
（2）子类的构造方法会自动调用父类不带参数的构造方法，不会调用带参数的构造方法；如果子类确实有必要调用父类带参数的构造方法，就必须使用super关键字实现
super（[参数列表]）;
使用super的规则：一、只能用在构造方法中；二、只能是第一条执行语句；三、一个构造方法只能有一条super语句
注：一旦显式的用super来调用父类的构造方法，系统就不会再自动的调用父类中无参数的构造方法。
子类继承父类的总结：
（1）如果子类没有定义构造方法，则调用父类的无参数的构造方法。
（2）如果子类定义了构造方法，无论是无参数还是带参数，在创建子类的对象的时候，首先执行父类无参数的构造方法，然后执行自己的构造方法；
（3）如果子类调用父类带参数的构造方法，可以通过super（参数）调用所需要的父类的构造方法，且该语句作为子类构造方法的第一条语句；
（4）如果某个构造方法调用类中的其它的构造方法，则可以用this（参数），且该语句放在构造方法的第一条语句的位置。

4 多态技术
java中多态性表现在两个方面：
方法的重载：在同一个类中，相同的方法名对应不同的方法实现，但是方法的参数不同；
成员覆盖：在不同类（父类和子类）中，允许有相同的变量名，但是参数类型不同；也允许有相同的方法名，但是对应的方法实现不同；
4.1 重载与覆盖
在一个类中，多个方法拥有相同的名字，名字相同的同时必须有不同的参数，这就是重载；
在父类与子类之间，有相同的属性名但类型不同或方法名相同但实现不同，就是子类对父类的成员或方法的覆盖。
4.1.1普通方法的重载
当方法同名时，至少需要之一不同，一、参数个数不同；二、对应位置上的参数类型不同；
注：不允许参数完全相同而只是返回值不同的情况出现。
除了普通实例方法的重载，静态方法之间也可以重载，它们的规则和实例方法的重载一样；甚至静态方法和实例方法之间也可以相互重载，同样要求参数之间有区别。
4.1.2构造方法的重载
相对于普通的成员方法，由于构造方法不能是static和final类型，而且也没有返回值，所以它的重载比普通成员方法更简单一些，但规则完全相同。
注意：如果程序员为类定义了一个构造方法，那么系统不会再自动为其添加一个无参数的构造方法；所以程序员如果要为类定义构造方法，为避免使用者的错误，请务必
定义一个不带参数的构造方法（即程序员无论何种情况，一定要为类定义一个不带参数的构造方法）
4.1.3重载的解析
扩展转换有两条路径：
byte short int long float double 
char int long float double
这两条路径中，位于左边的类型都可以扩展为右边的类型。
4.1.4重载与覆盖的区别
（1）重载与覆盖的方法名称都相同，但重载要求参数列表不同，而覆盖则要求参数列表完全相同。
（2）重载对于方法前面的

5 结口与多重继承

6 抽象类与最终类

7 内部类

8 包



