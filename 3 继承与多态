1 继承
[类修饰符] class 子类名 extends 父类名{
    类体
}
（1）子类会自定的继承父类中的所有定义的非private的成员变量和普通方法，唯有构造方法例外。
注：java出于安全性和可靠性的考虑，仅支持单重继承，而通过使用接口机制来实现多重继承；

2 继承中的属性隐藏与方法覆盖
当子类的成员变量和父类的成员变量同名时，称为父类的成员变量（属性）被隐藏；如果是成员方法同名，称为父类的成员方法（行为）被覆盖。
2.1 属性的隐藏
（1）子类变量可以修改继承下来的父类变量中的任何属性，使用子类对象时，以修改之后的属性为准；
（2）java规定，子类用于隐藏的变量可以和父类的访问权限不同，如果访问权限被改变，则以子类的权限为准。
（3）java允许子类的变量与父类的变量的类型完全不同，以修改后的数据类型为准。
（4）java允许父类的变量被子类的常量隐藏，也允许父类的常量被子类的变量隐藏。
2.2 方法的覆盖
子类中如果觉得继承下来的方法不能满足自己的要求，可以将其重写一遍，这被称为‘覆盖’；覆盖必须满足两个条件：
一、方法名称必须相同；二、方法的参数必须完全相同，包括参数的个数、类型和顺序。
如果只满足第一条，而不满足第一条，那么就不是覆盖，而是重载。
（1）子类方法的访问权限可以与父类的不相同，但只允许权限更宽松，而不是更严格。
（2）覆盖与被覆盖的方法的返回值数据类型必须完全相同。
（3）如方法前面有final修饰，则表示该方法是一个最终方法，它的子类不能覆盖该方法；反之，一个非最终方法，可以在子类中指定final修饰符，将其变成最终方法。
（4）java规定，静态方法不允许被实例方法覆盖；同样实例方法也不允许用静态方法覆盖；也就是说，不允许出现父类方法和子类方法覆盖时static修饰符发生变化

3 构造方法的继承与调用


4 多态技术

5 结口与多重继承

6 抽象类与最终类

7 内部类

8 包



