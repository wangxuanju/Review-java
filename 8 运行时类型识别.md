
一、java中的RTTI
举例：基类是Shape类，由它派生来的类是Circle/Squere/Triangele；这四个类都拥有同名的方法：draw();
```java
void draw(Shape shape){
    shape.draw();
}
```
```java
Circle circle = new Circle();
Squere squere = new Squere();
Triangle triangel = new Triangele();
Shape shape = new Shape();
Draw(circle);
Draw(circle);
Draw(circle);
Draw(circle);
```
shape.draw()实际上会执行4个不同的方法，它会根据实际执行时shape对象所属的真正类别来决定调用哪一个类的draw()方法；这个特性被称为运行时多态；

java提供了两种方式来获取对象的信息：一种是利用传统的方法；另一种是利用反射机制。
## RTTI的工作原理
Class类提供了很多有用的方法，其中forName()方法用来加载一个对象；使用它可以不必用关键字new来创建对象；它是一个静态方法，一般使用形式如下：
Class.froName("类名");
```java
class Candy {
  static {        //静态代码块
    System.out.println("Loading Candy in static block.");
  }
  public static void main(String args[]){
    System.out.println("Loading Candy in main method.");
  }
  public void showMsg(){
    System.out.println("Candy's method.");
  }  
}
```
```java
public class loadClass{
 public static void main(String args[]){
   System.out.println("Before loding Candy. ");
   try{
     Class candy=Class.forName("Candy");//通过Class.forName加载Candy对象；
   }catch(ClassNotFoundException e) {
      e.printStackTrace();
   }
 }
}
```
这种方式和利用new来创建对象的区别：用new创建对象通过编译器静态检查，如果编译时Candy类不存在，那么使用Candy对象的类也无法通过编译；
而forName()方法是动态加载的，即便编译时Candy类不存在，编译也是可以通过的，只是在运行时会抛出异常。
使用forName()方法另一个问题是：它返回的是一个Class类型，而不是加载的那个类的类型，只能写成：Class  candy = Class.forName("Canday");
所以使用forName()加载对象多用在加载驱动程序的情况下。

# 二、Java类的识别方法
## 使用getClass()方法获取类信息
获取对象所属类信息最常用的方法是getClass()方法（是一个Object类的最终方法，所有类都可以使用它，但不能覆盖它）
getClass()的原型如下：public final Class<? extends Object> getClass()
它的返回值是一个泛型类；获取返回值后，可以利用Class类的各种方法对对象进行处理。
 ```java
public class Shape{
  void showMsg(){
    System.out.println("This is Shape class");
  }
}

public class Circle extends Shape{
  void showMsg(){
    System.out.println("This is Circle class");
  }
}

public class getClassName{
  public static void main(String args[]){
    showName(new Circle()); //调用showName方法，分别传入Circle对象和Shape对象
    showName(new Shape());
  }
  public static void showName(Shape shape){
    Class cl = shape.getClass();     //获取shape实际所属的类
    System.out.println(cl.getName());
    if (cl.getName().equals("Shape"))   //对类进行判断，并做出相应处理
      System.out.println("This is a shape object.");
    else if(cl.getName().equals("Circle"))           
      System.out.println("This is a circle object.");
  }
}
```
程序中使用getName()方法获取类名，然后进行比较，判断所属的类。
## 使用类标记
Java提供了一种简便的生成Class对象的方法：类标记。如果T是任意的java类型，那么，T.class就代表匹配的类对象。
eg Class c1 = int.class;Class C2 = double[].class;Class c3 = Shape.class; 
```java
public class getClassName{
  public static void main(String args[]){
    showName(new Circle());              //调用showName方法，分别传入Circle对象和Shape对象
    showName(new Shape());
  }
  public static void showName(Shape shape){
    Class cl = shape.getClass();            //得到shape类对象
    System.out.println(cl.getName());
    if (cl == Shape.class)                     //使用==号对类类型进行判断
      System.out.println("This is a shape object.");
    else if(cl == Circle.class)
      System.out.println("This is a circle object.");
  }
}
```
## 使用关键字instanceof判断所属类
java提供了一个关键字instanceof，用于帮助程序员判断一个对象真正所属的类，它是一个二元运算符，一般形式如下：
objectName instance className
其中，左侧的操作数是一个对象名，右侧的操作数是类名，计算的结果为true或false.
```java
public class getClassName{
  public static void main(String args[]){
    showName(new Circle());       //调用showName方法，分别传入Circle对象和Shape对象
    showName(new Shape());
  }
  public static void showName(Shape shape){
    Class cl = shape.getClass();          //通过getClass方法得到shape类对象
    System.out.println(cl.getName());
    if (cl.isInstance(new  Shape()))                   //使用instanceof操作符对类类型进行判断
      System.out.println("This is a shape object.");
    else if(cl.isInstance(new Circle()))
      System.out.println("This is a circle object.");
  }
}
```
这个例子中instanceof有速度上的优势，但它仅仅是一个用来判断所属类的运算符，缺乏其他的功能，它完全可以被运行时多态取代；
而Class类则有相当多的辅助方法，能够被使用在反射机制中，满足程序员的各种需要，所以用途比较广泛。
# 三、利用反射获取运行时类信息
反射是java程序开发的特征之一，它允许运行中的java程序对自身进行检查；java的这一特性被大量应用于javaBean中；本节结束反射机制最重要的内容——检查类的结构。

```java
import java.lang.reflect.*;
public class DumpMethods{
   public static void main(String args[]) {
      try{
         Class c = Class.forName(args[0]);   //装载类命令行指定的类对象
         Method m[] = c.getDeclaredMethods();//获取类中声明的方法
         for (int i = 0; i < m.length; i++)
             System.out.println(m[i].toString());
     } catch (Throwable e) {
         System.err.println(e);
     }
  }
}
```
上例的程序先使用Class.forName载入指定的类，然后调用getDeclaredMethods()方法获取这个类中定义了的方法列表。
在java.lang.reflect包中，有三个重要的类：Filed/Method/Constructor，它们分别用来描述类的成员属性(域）、方法和构造器，这三个类都有一个getName()方法
它可以返回相应条目的名称。
使用这个类的时候，必须遵循三个步骤：
（1）获得想操作类的java.lang.Class对象。获取Class对象的方法，分别是forName()和类标记。
（2）调用诸如getDeclaredMethods()的方法，以取得该类中定义的所有方法的列表。
（3）使用reflection API来操作这些信息。
``java
Class C = Class.forName("java.lang.String");
Method m[] = c.getDeclaredMehods();
System.out.println(m[0].toString());
它将以文本的形式输出String中定义的第一个方法的原型。
```
## 使用isInstance()方法，可以用来替代instanceof关键字，原型的声明如下：
public boolean isInstance(Object obj)
它的参数不是一个类名，而是一个类所属的对象。
```java
public class useInstanceMethod{
  public static void main(String args[]){
    judage(new Circle());
    judge(new Shape());
  }
  public static void showName(Shape shape){
    Class cl = shape.getClass();
    System.out.println(cl.getName());
    if (cl.isInstance(new  Shape())) //注意它的参数
      System.out.println("This is a shape object.");
    else if(cl.isInstance(new Circle()))
      System.out.println("This is a circle object.");
  }
}
```
## 获取成员方法信息
找出一个类中定义了哪些方法，Class类中的getDeclaredMethods()方法以及Method类。
```java
import java.lang.reflect.*;
public class listMethods extends Circle{
   private int onlyTest(Object p, int x) throws NullPointerException {
       if (p == null)
          throw new NullPointerException();
       return x;
  }
  public static void main(String args[]){
     try {
       Class cls = Class.forName("listMethods");
       Method methlist[] = cls.getDeclaredMethods();
       for (int i = 0; i < methlist.length; i++){            //循环显示类中所有方法的信息
            System.out.println("------第"+i+"个方法------");
            Method m = methlist[i];
            System.out.println("name = " + m.getName());       //显示方法名称
            System.out.println("decl class = " + m.getDeclaringClass());//显示定义方法的类名称
            Class pvec[] = m.getParameterTypes();                 //显示方法所有的参数类型
            for (int j = 0; j < pvec.length; j++)
                System.out.println("param #" + j + " " + pvec[j]);
            Class evec[] = m.getExceptionTypes();                 //显示方法所有可能抛出的异常
            for (int j = 0; j < evec.length; j++)
                System.out.println("exc #" + j + " " + evec[j]);
            System.out.println("return type = " + m.getReturnType());        //显示方法的返回值类型
       }
    } catch (Throwable e){
        System.err.println(e);
    }
 }
}
```
本类是一个子类，却没有列出从父类Circle中继承下来的方法；如果想要获取父类的方法，需要在程序中使用getMethods()方法来代替getDeclaredMethods()方法
（不过只是获取所以public类型的方法）。











