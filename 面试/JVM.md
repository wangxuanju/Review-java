# JVM
## JVM的类加载机制
JVM把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成被JVM直接使用的Java类型。
## 类加载的全过程
就是加载、验证、准备、解析、初始化这5个阶段所执行的具体动作。
### 加载
通过一个类的全限定名获取定义此类的二进制字节流；字节流所代表的静态存储结构转化为方法区的运行时数据结构；内存中生成一个代表这个类的java.lang.Class对象，
作为方法区这个类的各种数据的访问接口。
### 验证
确保Class文件的字节流包含的信息符合当前虚拟机的要求
### 准备
为类变量分配内存并设置类变量初始值
### 解析
将常量池内的符号引用替换为直接引用
### 初始化
执行类中的Java程序代码

## 双亲委派模型
双亲委派模型处理顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器，类加载器之间通过组合关系来实现。

（启动类加载器---扩展类加载器---应用程序类加载器---自定义类加载器）
### 工作过程：
一个类的加载器首先将类加载请求传送到父类加载器，当父类加载器无法完成请求时，才尝试自己去加载。
### 好处
使Java类随着它的类加载器一起具有一种带优先级的层次关系，从而使基础类得到统一
### 什么时候需要打破双亲委派模型？
Java中所以涉及SPI的加载动作，例如JNDI/JDBC等

## Java虚拟机的内存区域，这些区域的作用、服务对象及可能产生的问题？
Java虚拟机在执行Java程序的过程中把它管理的内存划分为不同的数据区域
### 程序计数器
当前线程所执行字节码的行号指示器
### Java虚拟机栈
每个Java方法执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息，从调用到执行完成，对应着一个栈帧在虚拟机中入栈和出栈的过程
### 本地方法栈
本地方法栈为虚拟机栈使用的本地方法服务
### Java堆
被所有线程共享的内存区域，存放对象实例（垃圾收集器的主要区域，也称“GC”堆）
### 方法区
各个线程所共享的内存区域，存储被虚拟机加载的类信息、常量、静态变量、即时服务器编译后的代码等数据
### 运行时常量池
方法区的一部分，Class文件中的常量池会在类加载后放入这个区域
### 直接内存
使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuff对象作为这块内存的引用进行操作。

## 垃圾回收（GC）算法
需要排查各种内存溢出、内存泄露问题时，当垃圾收集成为系统达更高并发量瓶颈时，就需要对其进行必要的监控和调节。
### 标记清除
标记所有需要回收的对象，标记完成后统一回收（会产生大量不连续的空间碎片，无法给大对象分配内存）
### 标记整理
让所有存活的对象向一侧移动，清理掉边界以外的内存
### 复制
将可用内存划分为大小相等的两块，每次用其中一块，这一块使用完之后就把还存活的对象复制到另一块上，把使用过的内存空间进行清理。
### 分代收集
根据对象存活周期将内存分为几块，不同块采用适当的收集算法

新生代：复制算法

老年代：标记清除或标记整理算法

## 垃圾收集器
### G1
面向服务端应用，多CPU和大内存场景下使用（并行与并发、分代收集、空间整合和可预测的停顿）

使用G1收集器时，Java堆的内存布局将整个Java堆分成多个大小相等的独立区域（Regin），使用Regina划分内存空间以及有优先级的区域回收方式，在有限的时间内可以获取尽可能高的收集效率。

#### 特点
空间整合：整体看基于标记清除算法，局部看基于复杂算法，意味着运行期不会产生内存空间碎片。

可预测的停顿

### CMS
一种获取最短回收停顿时间为目标的收集器，应用于互联网站或B/S系统的服务端上（并行收集、低停顿）

缺点：吞吐量低、无法处理浮动垃圾、基于标记清除算法导致空间碎片







