<!-- GFM-TOC -->
* [一、继承](#一继承)
* [二、继承中的属性隐藏与方法覆盖](#二继承中的属性隐藏与方法覆盖)
    * [属性的隐藏](#属性的隐藏)
    * [方法的覆盖](#方法的覆盖)
* [三、构造方法的继承与调用](#三构造方法的继承与调用)
    * [构造方法的定义](#构造方法的定义)
    * [构造方法的继承](#构造方法的继承)
    * [构造方法的覆盖](#构造方法的覆盖)
    * [super关键字的使用](#super关键字的使用)
* [四、多态技术](#四多态技术)
    * [重载与覆盖](#)
    * [重难点——运行时多态](#重难点——运行时多态)
* [五、结口与多重继承](#五结口与多重继承)
    * [接口的定义](#接口的定义)
    * [接口的继承](#接口的继承)
    * [接口的实现](#接口的实现)
* [六、抽象类与最终类](#六抽象类与最终类)
    * [抽象方法的声明](#抽象方法的声明)
    * [抽象类的定义](#抽象类的定义)
    * [抽象方法与回调函数](#抽象方法与回调函数)
    * [最终方法](#最终方法)
* [七、内部类（重点章节）](#七内部类（重点章节）)
    * [嵌入类](#嵌入类)
    * [内部成员类](#内部成员类)
    * [本地类](#本地类)
    * [内部类访问外部类的成员](#)
    * [内部类之间的相互使用](#)
    * [在外部使用内部类](#在外部使用内部类)
    * [匿名内部类](#匿名内部类)
<!-- GFM-TOC -->



# 一、继承
```java
[类修饰符] class 子类名 extends 父类名{
    类体
}
```
（1）子类会自定的继承父类中的所有定义的非private的成员变量和普通方法，唯有构造方法例外。

注：java出于安全性和可靠性的考虑，仅支持单重继承，而通过使用接口机制来实现多重继承；

# 二、继承中的属性隐藏与方法覆盖
当子类的成员变量和父类的成员变量同名时，称为父类的成员变量（属性）被隐藏；如果是成员方法同名，称为父类的成员方法（行为）被覆盖。
## 属性的隐藏
（1）子类变量可以修改继承下来的父类变量中的任何属性，使用子类对象时，以修改之后的属性为准；

（2）java规定，子类用于隐藏的变量可以和父类的访问权限不同，如果访问权限被改变，则以子类的权限为准。

（3）java允许子类的变量与父类的变量的类型完全不同，以修改后的数据类型为准。

（4）java允许父类的变量被子类的常量隐藏，也允许父类的常量被子类的变量隐藏。

## 方法的覆盖
子类中如果觉得继承下来的方法不能满足自己的要求，可以将其重写一遍，这被称为‘覆盖’；覆盖必须满足两个条件：
一、方法名称必须相同；二、方法的参数必须完全相同，包括参数的个数、类型和顺序。
如果只满足第一条，而不满足第一条，那么就不是覆盖，而是重载。

（1）子类方法的访问权限可以与父类的不相同，但只允许权限更宽松，而不是更严格。

（2）覆盖与被覆盖的方法的返回值数据类型必须完全相同。

（3）如方法前面有final修饰，则表示该方法是一个最终方法，它的子类不能覆盖该方法；反之，一个非最终方法，可以在子类中指定final修饰符，将其变成最终方法

（4）java规定，静态方法不允许被实例方法覆盖；同样实例方法也不允许用静态方法覆盖；也就是说，不允许出现父类方法和子类方法覆盖时static修饰符发生变化

# 三、构造方法的继承与调用
从形式上看，构造方法没有返回值，没有static和final等修饰符，而且一般不会用private修饰。
## 构造方法的定义
java中任何变量在被使用前都必须先设置初值，java提供了为类的成员变量赋初值的专门方法即构造方法；

（1）构造方法的名字必须与定义的类名完全相同，没有返回值，甚至连void都没有。

（2）构造方法的调用在创建一个对象时使用new操作进行的；构造方法的作用时初始化对象。

（3）每个类可以有0个或多个构造方法。

（4）不能被static/final/synchronized/abstract/native修饰。

## 构造方法的继承
（1）父类中不带参数的构造方法能够被子类自动继承，这种继承与普通方法的继承本质上并不相同，它其实是一种自动调用；

（2）java规定，带参数的构造方法，不会由子类继承，也不会自动调用；

## 构造方法的覆盖
（1）构造方法在覆盖时，只可能是访问权限不同；而且它遵循普通方法的限制，只允许访问权限更宽松。java还规定，子类中无论当哪个构造方法在执行时，都会先执行
父类中无参数的构造方法。

（2）子类的构造方法在执行时，会先调用父类中无参数的构造方法；因此在设计一个类时，最好为父类提供一个无参数的构造方法。

## super关键字的使用
子类的变量和方法都可以和父类中的同名；在这种情况下，父类中的同名成员就被屏蔽起来——注意仅仅只是屏蔽，而不是清除；如果想在子类中访问父类的成员，就需要
用到关键字super。
super的一般用法：super.变量名 或 super.方法名（[参数列表]） 
super的另外一个作用是显式的调用父类的构造方法： super（[参数列表]）

（1）关键字super引用被隐藏的变量和访问被覆盖的父类方法；

（2）子类的构造方法会自动调用父类不带参数的构造方法，不会调用带参数的构造方法；如果子类确实有必要调用父类带参数的构造方法，就必须使用super关键字实现
super（[参数列表]）;

使用super的规则：一、只能用在构造方法中；二、只能是第一条执行语句；三、一个构造方法只能有一条super语句
注：一旦显式的用super来调用父类的构造方法，系统就不会再自动的调用父类中无参数的构造方法。
子类继承父类的总结：
（1）如果子类没有定义构造方法，则调用父类的无参数的构造方法。

（2）如果子类定义了构造方法，无论是无参数还是带参数，在创建子类的对象的时候，首先执行父类无参数的构造方法，然后执行自己的构造方法；

（3）如果子类调用父类带参数的构造方法，可以通过super（参数）调用所需要的父类的构造方法，且该语句作为子类构造方法的第一条语句；

（4）如果某个构造方法调用类中的其它的构造方法，则可以用this（参数），且该语句放在构造方法的第一条语句的位置。

# 四、多态技术
java中多态性表现在两个方面：
方法的重载：在同一个类中，相同的方法名对应不同的方法实现，但是方法的参数不同；
成员覆盖：在不同类（父类和子类）中，允许有相同的变量名，但是参数类型不同；也允许有相同的方法名，但是对应的方法实现不同；
## 重载与覆盖
在一个类中，多个方法拥有相同的名字，名字相同的同时必须有不同的参数，这就是重载；
在父类与子类之间，有相同的属性名但类型不同或方法名相同但实现不同，就是子类对父类的成员或方法的覆盖。
### 普通方法的重载
当方法同名时，至少需要之一不同，一、参数个数不同；二、对应位置上的参数类型不同；
注：不允许参数完全相同而只是返回值不同的情况出现。
除了普通实例方法的重载，静态方法之间也可以重载，它们的规则和实例方法的重载一样；甚至静态方法和实例方法之间也可以相互重载，同样要求参数之间有区别。
### 构造方法的重载
相对于普通的成员方法，由于构造方法不能是static和final类型，而且也没有返回值，所以它的重载比普通成员方法更简单一些，但规则完全相同。
注意：如果程序员为类定义了一个构造方法，那么系统不会再自动为其添加一个无参数的构造方法；所以程序员如果要为类定义构造方法，为避免使用者的错误，请务必
定义一个不带参数的构造方法（即程序员无论何种情况，一定要为类定义一个不带参数的构造方法）
### 重载的解析
扩展转换有两条路径：
byte short int long float double 
char int long float double
这两条路径中，位于左边的类型都可以扩展为右边的类型。
### 重载与覆盖的区别
（1）重载与覆盖的方法名称都相同，但重载要求参数列表不同，而覆盖则要求参数列表完全相同。
（2）重载对于方法前面的修饰符没有限制，而覆盖则对这些修饰符的使用有限制。
（3）同一类中的方法能够互相重载，但不能相互覆盖；子类对父类的方法既可以重载又可以覆盖。
（4）重载是一个类中多态性的一种表现，覆盖是父类与子类之间多态性的一种表现。
## 重难点——运行时多态


# 五、结口与多重继承
## 接口的定义
[访问权限修饰符] interface 接口名 [extends 父接口1，父接口2，...]{
    [public][static][final]数据类型 变量名=初始值；//定义成员变量
    ....
    [public][abstract] 返回类型 方法名 （[参数列表]）//定义成员方法
}
（1）interface表明这是一个接口，访问权限修饰符和类使用的一样，默认访问权是包访问权，一般用public来修饰它；和类的区别是，接口都是abstract的，所以
无需用abstract来修饰；

（2）接口中的成员变量都是常量；接口中的成员变量的属性都是静态的、最终的，也就是静态常量；接口中不允许使用private和protected关键字，意味着所有的属性
都是public类型的。

（3）接口中的成员方法都是抽象方法；所有的方法都是具有public访问权限的抽象实例方法。

（4）接口中的方法都是抽象的，而构造方法不可能是抽象方法，因此接口中没有构造方法。

## 接口的继承
接口的继承规则和类的继承是相同的。
## 接口的实现
实现接口的一般形式：
```java
[类修饰符] class 类名 [extends父类名] [implements 接口名1 [,接口名2，...]]{
    //实现接口中的抽象方法
    public [返回值类型] 方法名 （[参数表]）{
        //方法体
    }
}
```
注：实现接口中的方法时，它的访问权限一定要是public类型；它的参数、返回值也要和接口中的形式完全一致；
（1）接口最终要用类来实现；类在实现接口时，不再使用关键字extends，而是使用implements；

（2）若干没有继承关系的类可以实现同一个接口，一个类可以实现多个接口，这些接口被称为父接口或超接口；

（3）由于接口中只有抽象方法，所以一个非抽象的类必须实现父接口中所有的方法；若父接口继承了其它的接口，则这些接口的抽象方法也要由该类来实现；若是该类
同时是某些类的子类，而其父类实现了这些接口中的一部分方法，则该类只要能继承这些方法，也就视为对这些抽象方法的实现；

（4）虽然接口不能直接用来创建对象，但是接口中定义的成员变量是可以直接使用的，因为静态成员不需要创建对象就可以通过‘接口名.变量名’的方式来使用；

# 六、抽象类与最终类
## 抽象方法的声明
java中提供了抽象类，它只能作为父类，不能实例化。
抽象方法是一种只有方法而没有方法体定义的特殊方法；它的声明部分和一般方法没有太大的区别，只是需要在前面加上一个关键字abstract，形式如下：
abstract 访问权限 返回类型 方法名([参数列表]);
声明抽象方法有几个限制：
（1）构造方法不能声明为abstract;

（2）静态方法不能声明为abstract;

（3）private方法不能声明为abstract;

（4）final方法不能声明为abstract;

（5）抽象方法只能出现在抽象类或接口中；

## 抽象类的定义
定义一个抽象类，只需要在类的头部加上关键字abstract;
```java
abstract class className{
    类体
}
```
在抽象类中，可以有0个或多个抽象方法，也可以有普通的实例方法和静态方法，还可以有其它的成员变量和构造方法；如果类中没有任何形式的抽象方法，那么可以由
程序员自主决定是否将类声明为abstract类型；
符合下面条件之一，则类必定为抽象类，必须加上abstract修饰：
（1）类中明确声明有abstract方法；

（2）类是从抽象类继承下来的，而且没有实现父类中全部的抽象方法；

（3）类实现了一个接口，但没有将其中所有的抽象方法实现；

## 抽象方法与回调函数
在抽象类中，既可以有抽象方法，也可以有普通方法，而且普通方法还可以调用抽象方法；
抽象方法不能是静态方法，因为静态方法无需对象就能执行；
## 最终类与最终方法
### 最终类
最终类定义的一般形式：
```java
[访问权限] final class 类名{
    类体
}
```
（1）如果一个类不希望被其它类所继承，则可以声明为final类，这样就可以防止其它类以它作为父类；最终类通常是有某个固定作用的类，如system/string类等。

（2）最终类显然不可能是抽象类；由于最终类不能有子类，那么它所拥有的所有方法都不可能被覆盖，因此它其中所有的方法都是最终方法。

##最终方法
如果一个类允许被其它类所继承，只是其中的某些方法不允许被子类覆盖，那么可以将这些方法声明为最终方法，这需要在声明前面加上关键字final；
[访问权限] final 返回类型 方法名 （[参数列表]）
使用最终方法时，注意两点：
一、最终方法可以出现在任何类中，但不能和abstract修饰符同时使用；

二、最终方法不能被覆盖，但可以被重载；

# 七、内部类（重点章节）
内部类是定义在另外一个类的里面；内部类分为三种：嵌入类、内部成员类和本地类。
（1）当类的前面有static修饰符时，它就是嵌入类；嵌入类只能和外部类的成员并列，不能定义在方法中；

（2）如果类和外部类的成员是并列定义的，且没有static修饰，则该类为内部成员类；

（3）如果类是定义在某个方法中，则该类称为本地类；

## 嵌入类
嵌入类——当内部类的前面用static修饰时，它就是一个嵌入类；它和外部类的其他成员属性和方法处在同一层次上。
```java
[访问权限修饰符] static class 类名 [extends父类名] [implements 接口列表]{
    类体
}
```
（1）在嵌入类的类体中，可以定义任何类型的成员属性和方法，这一点与顶层类完全相同；它本身可以是final类型或者是abstract类型，也可以被其它类所继承。

（2）嵌入类不能和包含它的外部类同名，也不能和其它的成员同名；

（3）嵌入类和顶层类的类体定义几乎没什么区别；由于嵌入类本身是外部类的成员，所以可以具有一般成员的访问权限，包括public/protected/private和默认；

## 内部成员类
内部成员类——如果内部类的前面不用static修饰，则它是一个内部成员类；它的地位与类的实例成员相当，所以也被称为内部实例成员类
```java
[访问权限修饰符] class 类名[extends父类名][implements接口列表]{
    类体
}
```
（1）内部成员类尽管自己不能定义静态成员，但可以继承父类的静态成员；
## 本地类
本地类——内部类可以定义在方法之中，称为本地类
（1）无论方法本身是静态方法还是实例方法，本地类都不能用static修饰；

（2）它的类体中与内部成员类一样，除了静态成员常量之外，不允许定义任何静态成员；

（3）本地类的作用域是定义它的方法，所以它没有访问类型；

（4）本地类的地位相当于定义了一个局部数据类型；

（5）本地类不仅可以定义在一个方法的里面，甚至可以定义在语句块里面，那么它的有效范围仅限于语句块；

（6）本地类尽管不能定义静态成员，但可以通过继承来拥有静态成员；

（7）不同方法中的本地类是可以同名的，甚至也可以和嵌入类及内部成员类同名（当然最好不要这样做）

## 内部类访问外部类的成员
### 嵌入类访问外部类成员
嵌入类本身是用static修饰的，所以编译器认为嵌入类里面所有的成员都处于静态环境中，因此只能访问外部类的静态成员；
嵌入类在访问本类中的成员时，遵循一般类的规则，只是当它访问外部类的成员时，由于受到类前面的static的限制，只能访问外部的静态成员；
### 内部成员类访问外部类成员
内部成员类中不能定义静态成员，但它的实例方法可以访问外部类的静态和实例成员；
内部成员类里面的方法在访问外部成员时，没有任何限制；
### 实例方法中的本地类访问外部成员
如果本地类位于实例方法中，那么它像内部成员类一样，可以访问外部类的任意成员。除此之外，包含本地类的方法还可以定义局部变量；本地类只能访问局部常量，而
不允许访问局部变量。
### 静态方法中的本地类访问外部成员
如果本地类位于静态方法中，那么它处于静态环境中，只能访问外部类的静态成员；另外，它也只能访问局部的常量，而不允许访问局部变量；
## 内部类之间的相互使用
由于嵌入类是静态的，所以它只能使用其他的嵌入类，而不允许使用内部成员类；
内部成员类则可以使用嵌入类和其它的内部成员类；
本地类的作用域只限于定义它的方法，所以嵌入类和内部成员类都不能使用本地类；
本地类可以随意使用嵌入类，但在使用内部成员类时，受到方法本身的限制。只有定义在实例方法中的本地类才能使用内部成员类，同一方法中的本地类可以互相使用。
## 在外部使用内部类
对于嵌入类和内部成员类，只要他们的访问权限不是private，则可以在外部使用这些类，只是使用方式有所不同；对于本地类，在外部是无法使用的。
如果是嵌入类，可以像使用静态成员一样，通过‘外部类名.嵌入类名’的方式使用。由于内部成员类是非静态的，必须通过外部类的实例进行引用。
## 匿名内部类
匿名内部类——程序定义一个内部类之后只要创建这个类的一个对象，就不必为这个类命名
```java
new interfaceName(){
    类体
}
或
new superClassName([实际参数]){
    类体
}
```
匿名类是没有名字的，interfaceName和superClassName并不是它的名字，而是它要继承的接口或类的名字；括号中的参数是用来传递给父类的构造方法。
匿名类没有构造方法，取而代之的是将参数传递给父类的构造方法（由于构造方法必须与类名相同，而匿名类没有类名）；
使用一个匿名类：形式如下：
```java
superClassName oa = new superClassName(参数){类体}；匿名内部类后面有大括号括起来的类体；
```
由于匿名类在创建的同时必须要创建对象，所以不能用static修饰。如果它与类的其它成员并列，那么它与内部成员类的定义没有区别；如果它是在一个成员方法中，那么
与本地类的规则形同。
实际上所以匿名内部类都不是必须的，可以用内部类取代；
